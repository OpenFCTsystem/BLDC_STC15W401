C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN_V20
OBJECT MODULE PLACED IN .\list\main-V20.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main-V20.c BROWSE DEBUG OBJECTEXTEND PRINT(.\list\main-V20.lst) OBJECT(.\li
                    -st\main-V20.obj)

line level    source

   1          
   2          /*---------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited ----------------------------------*/
   4          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   5          /* --- Mobile: 13922805190 --------------------------------------------*/
   6          /* --- Fax: 0513-55012956,55012947,55012969 ---------------------------*/
   7          /* --- Tel: 0513-55012928,55012929,55012966 ---------------------------*/
   8          /* --- Web: www.GXWMCU.com   www.stcmcu.com ---------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* Èç¹ûÒªÔÚ³ÌÐòÖÐÊ¹ÓÃ´Ë´úÂë,ÇëÔÚ³ÌÐòÖÐ×¢Ã÷Ê¹ÓÃÁËºê¾§¿Æ¼¼µÄ×ÊÁÏ¼°³ÌÐò   */
  11          /*---------------------------------------------------------------------*/
  12          
  13          
  14          /*************  ¹¦ÄÜËµÃ÷        **************
  15          
  16          ±¾³ÌÐòÊÔÑéÊ¹ÓÃSTC15W401AS-35I-SOP16<RMB1.6>À´Çý¶¯º½Ä£ÓÃµÄÎÞ´«¸ÐÆ÷ÎÞË¢ÈýÏàÖ±Á÷Âí´ï.
  17          
  18          ±¾³ÌÐò²Î¿¼×ÔÍøÉÏµÄ´úÂë(×÷Õß: ÈðÉú), ¸ÄÁ¼¶øÀ´.
  19          
  20          µçÂ·Í¼¼ûÎÄ¼þ "BLDC-V10-ÊµÑéµçÂ·.pdf".
  21          
  22          ¿ØÖÆÐÅºÅÓÉP3.2ÊäÈëÕýÂö³åÐÅºÅ, ¼ä¸ô5~20ms, Âö³å¿í¶È1.000~1.610ms.
  23          
  24          1.160ms¿ªÊ¼Æô¶¯, 1.610msÎª×î¸ßËÙ¶È, ·Ö±æÂÊÎª2us.
  25          
  26          ±¾³ÌÐò½ö½öÊÇ¼òµ¥¿ØÖÆ, Èí¼þÃ»ÓÐ´¦Àí ¹ý0ÑÓÊ±30¶ÈÇÐ»» ¹ýÁ÷¼ì²â.
  27          
  28          ÓÉÓÚ¹ý0¼ì²â²¿·ÖÓÐRCÂË²¨, ËùÒÔ¸Ä±äµçÈÝÖµ¿ÉÒÔ´óÔ¼µÄ¶ÔÓ¦ÔÚ×î¸ßËÙÊ±ÑÓÊ±30¶ÈµÄÊ±¼ä.
  29          
  30          ÓÐÒâÕß¿É×ÔÐÐÍêÉÆµçÂ·ºÍ³ÌÐò.
  31          
  32          ******************************************/
  33          
  34          
  35          
  36          
  37          #define MAIN_Fosc               24000000L       //¶¨ÒåÖ÷Ê±ÖÓ
  38          
  39          #include "STC15Fxxxx.H"
  40          
  41          #define         MCU_PIN         16      /* Ñ¡ÔñMCUÒý½ÅÊý, Ö»Ö§³Ö16»ò20½Å(28½Å»ò32½Å¸ú20½ÅÒ»Ñù) */
  42          
  43          // #include "reg51.h"
  44          #include "intrins.h"
  45          
  46          typedef unsigned char BYTE;
  47          typedef unsigned int WORD;
  48          void SendData(BYTE dat);
  49          void SendString(char *s);
  50          // #define FOSC 11059200L          //ÏµÍ³ÆµÂÊ
  51          // #define BAUD 115200             //´®¿Ú²¨ÌØÂÊ
  52          
  53          #define NONE_PARITY     0       //ÎÞÐ£Ñé
  54          #define ODD_PARITY      1       //ÆæÐ£Ñé
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 2   

  55          #define EVEN_PARITY     2       //Å¼Ð£Ñé
  56          #define MARK_PARITY     3       //±ê¼ÇÐ£Ñé
  57          #define SPACE_PARITY    4       //¿Õ°×Ð£Ñé
  58          
  59          #define PARITYBIT NONE_PARITY   //¶¨ÒåÐ£ÑéÎ»
  60          
  61          
  62          
  63          //CMPCR1
  64          #define CMPEN   0x80    //1: ÔÊÐí±È½ÏÆ÷, 0: ½ûÖ¹,¹Ø±Õ±È½ÏÆ÷µçÔ´
  65          #define CMPIF   0x40    //±È½ÏÆ÷ÖÐ¶Ï±êÖ¾, °üÀ¨ÉÏÉýÑØ»òÏÂ½µÑØÖÐ¶Ï, Èí¼þÇå0
  66          #define PIE             0x20    //1: ±È½Ï½á¹ûÓÉ0±ä1, ²úÉúÉÏÉýÑØÖÐ¶Ï
  67          #define NIE             0x10    //1: ±È½Ï½á¹ûÓÉ1±ä0, ²úÉúÏÂ½µÑØÖÐ¶Ï
  68          #define PIS             0x08    //ÊäÈëÕý¼«ÐÔÑ¡Ôñ, 0: Ñ¡ÔñÍâ²¿P5.5×öÕýÊäÈë,           1: ÓÉADCIS[2:0]ËùÑ¡ÔñµÄADCÊäÈë¶Ë×öÕ
             -ýÊäÈë.
  69          #define NIS             0x04    //ÊäÈë¸º¼«ÐÔÑ¡Ôñ, 0: Ñ¡ÔñÄÚ²¿BandGapµçÑ¹BGv×ö¸ºÊäÈë, 1: Ñ¡ÔñÍâ²¿P5.4×öÊäÈë.
  70          #define CMPOE   0x02    //1: ÔÊÐí±È½Ï½á¹ûÊä³öµ½P1.2, 0: ½ûÖ¹.
  71          #define CMPRES  0x01    //±È½Ï½á¹û, 1: CMP+µçÆ½¸ßÓÚCMP-,  0: CMP+µçÆ½µÍÓÚCMP-,  Ö»¶Á
  72          
  73          //CMPCR2
  74          #define INVCMPO 0x80    //1: ±È½ÏÆ÷Êä³öÈ¡·´,  0: ²»È¡·´
  75          #define DISFLT  0x40    //1: ¹Ø±Õ0.1uFÂË²¨,   0: ÔÊÐí
  76          #define LCDTY   0x00    //0~63, ±È½Ï½á¹û±ä»¯ÑÓÊ±ÖÜÆÚÊý
  77          
  78          #if     (MCU_PIN == 20)
                      sbit PWM2_L = P3^4;
                      sbit PWM1_L = P3^5;
                      sbit PWM0_L = P3^6;
              #endif
  83          
  84          #if     (MCU_PIN == 16)
  85                  sbit PWM2_L = P5^5;             // C-
  86                  sbit PWM1_L = P3^3;             // B-
  87                  sbit PWM0_L = P3^6;             // A-
  88          #endif
  89          
  90          u8      Step;
  91          u8      PWM_Value; // ¾ö¶¨PWMÕ¼¿Õ±ÈµÄÖµ
  92          u16     RxPulseWide;
  93          bit     B_RxOk;
  94          bit     B_RUN;
  95          u8      PWW_Set;
  96          u8      cnt10ms;
  97          u8      Rx_cnt;
  98          u8      TimeOut;        //¶Â×ª³¬Ê±
  99          
 100          #define DISABLE_CMP_INT CMPCR1 &= ~0X40         // ¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 101          #define ENABLE_CMP_INT  CMPCR1 |= 0X40          // ´ò¿ª±È½ÏÆ÷ÖÐ¶Ï
 102          
 103          /*************************/
 104          
 105          void    Delay_n_ms(u8 dly)
 106          {
 107   1              u16     j;
 108   1              do
 109   1              {
 110   2                      j = MAIN_Fosc / 13000;  //ÑÓÊ±1ms, Ö÷³ÌÐòÔÚ´Ë½ÚÅÄÏÂÔËÐÐ
 111   2                      while(--j)      ;
 112   2              }while(--dly);
 113   1      }
 114          
 115          
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 3   

 116          void delay_us(u8 us)
 117          {
 118   1              do
 119   1              {
 120   2                      NOP(20);        //@24MHz
 121   2              }
 122   1              while(--us);
 123   1      }
 124          
 125          void StepXL(void) // »»ÏàÐòÁÐº¯Êý
 126          {
 127   1       switch(Step)
 128   1        {
 129   2         case 0:  // AB
 130   2                              PWM0_L=0;       PWM2_L=0;
 131   2                              PWM0_OUT_1();
 132   2                              PWM1_OUT_1();
 133   2                              PWM2_OUT_1();
 134   2                              PWM0_NORMAL();
 135   2                              CCAP0H = PWM_Value;             // ´ò¿ªAÏàµÄ¸ß¶Ë
 136   2                              PWM1_L = 1;             // ´ò¿ªBÏàµÄµÍ¶Ë
 137   2                              ADC_CONTR = 0XED;       // Ñ¡ÔñP1.5×÷ÎªADCÊäÈë ¼´cÏàµçÑ¹
 138   2                              CMPCR1 = 0x9C;          //bit7=1 ÔÊÐí±È½ÏÆ÷, bit4=1 ±È½Ï½á¹ûÓÉ1±ä0, ²úÉúÏÂ½µÑØÖÐ¶Ï (²»ÄÜÏìÓ¦ÏÂ½µÑØÖÐ¶Ï?)
 139   2                      break;
 140   2         case 1:  // AC
 141   2                              PWM0_L=0;       PWM1_L=0;
 142   2                              PWM0_OUT_1();
 143   2                              PWM1_OUT_1();
 144   2                              PWM2_OUT_1();
 145   2                              PWM0_NORMAL();
 146   2                              CCAP0H = PWM_Value;             // ´ò¿ªAÏàµÄ¸ß¶Ë
 147   2                              PWM2_L = 1;                     // ´ò¿ªCÏàµÄµÍ¶Ë
 148   2                              ADC_CONTR = 0XEC;       // Ñ¡ÔñP1.4×÷ÎªADCÊäÈë ¼´BÏàµçÑ¹
 149   2                              CMPCR1 = 0xAC;          //ÉÏÉýÑØÖÐ¶Ï
 150   2               
 151   2              break;
 152   2         case 2:  // BC
 153   2                              PWM0_L=0;       PWM1_L=0;
 154   2                              PWM0_OUT_1();
 155   2                              PWM1_OUT_1();
 156   2                              PWM2_OUT_1();
 157   2                              PWM1_NORMAL();
 158   2                              CCAP1H = PWM_Value; // ´ò¿ªBÏàµÄ¸ß¶Ë
 159   2                              PWM2_L = 1;                     // ´ò¿ªCÏàµÄµÍ¶Ë
 160   2                              ADC_CONTR = 0XEB;       // Ñ¡ÔñP1.3×÷ÎªADCÊäÈë ¼´aÏàµçÑ¹
 161   2                              CMPCR1 = 0x9C;          //ÏÂ½µÑØÖÐ¶Ï
 162   2              break;
 163   2         case 3:  // BA
 164   2                              PWM1_L=0;       PWM2_L=0;
 165   2                              PWM0_OUT_1();
 166   2                              PWM1_OUT_1();
 167   2                              PWM2_OUT_1();
 168   2                              PWM1_NORMAL();
 169   2                              CCAP1H = PWM_Value; // ´ò¿ªBÏàµÄ¸ß¶Ë
 170   2                              PWM0_L = 1;                     // ´ò¿ªAÏàµÄµÍ¶Ë
 171   2                              ADC_CONTR = 0XED;       // Ñ¡ÔñP1.5×÷ÎªADCÊäÈë ¼´cÏàµçÑ¹ 
 172   2                              CMPCR1 = 0xAC;          //ÉÏÉýÑØÖÐ¶Ï
 173   2                              
 174   2              break;
 175   2         case 4: // CA
 176   2                              PWM1_L=0;       PWM2_L=0;
 177   2                              PWM0_OUT_1();
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 4   

 178   2                              PWM1_OUT_1();
 179   2                              PWM2_OUT_1();
 180   2                              PWM2_NORMAL();
 181   2                              CCAP2H = PWM_Value; // ´ò¿ªCÏàµÄ¸ß¶Ë
 182   2                              PWM0_L = 1;                     // ´ò¿ªAÏàµÄµÍ¶Ë
 183   2                              ADC_CONTR = 0XEC;       // Ñ¡ÔñP1.4×÷ÎªADCÊäÈë ¼´BÏàµçÑ¹
 184   2                              CMPCR1 = 0x9C;          //ÏÂ½µÑØÖÐ¶Ï
 185   2              break;
 186   2         case 5: // CB
 187   2                      PWM0_L=0;       PWM2_L=0;
 188   2                              PWM0_OUT_1();
 189   2                              PWM1_OUT_1();
 190   2                              PWM2_OUT_1();
 191   2                              PWM2_NORMAL();
 192   2                              CCAP2H = PWM_Value; // ´ò¿ªCÏàµÄ¸ß¶Ë
 193   2                      PWM1_L = 1;                     // ´ò¿ªBÏàµÄµÍ¶Ë
 194   2                              ADC_CONTR = 0XEB;       // Ñ¡ÔñP1.3×÷ÎªADCÊäÈë ¼´aÏàµçÑ¹
 195   2                              CMPCR1 = 0xAC;          //ÉÏÉýÑØÖÐ¶Ï
 196   2               
 197   2                      break;
 198   2               
 199   2              default:
 200   2                      break;
 201   2        }     
 202   1      }
 203          
 204          
 205          
 206          void PWM_Init(void)
 207          {
 208   1              PWM0_L = 0;
 209   1              PWM1_L = 0;
 210   1              PWM2_L = 0;
 211   1              
 212   1              #if     (MCU_PIN == 20)
                              P3n_push_pull(0x70);
                      #endif
 215   1              #if     (MCU_PIN == 16)
 216   1                      P3n_push_pull(0x48);
 217   1                      P5n_push_pull(0x20);
 218   1              #endif
 219   1      
 220   1              // CMOD = 1 << 1; //Ñ¡ÔñÏµÍ³Ê±ÖÓ/2ÎªÊ±ÖÓÔ´£¬¼´PWMÆµÂÊ=24M/2/256=46.9K
 221   1              CMOD = 5 << 1; //Ñ¡ÔñÏµÍ³Ê±ÖÓ/4ÎªÊ±ÖÓÔ´£¬¼´PWMÆµÂÊ=24M/4/256=23.4K
 222   1              // CMOD = 6 << 1; //Ñ¡ÔñÏµÍ³Ê±ÖÓ/6ÎªÊ±ÖÓÔ´£¬¼´PWMÆµÂÊ=24M/6/256=15.6K
 223   1              CL=0;                   // PCA¼ÆÊýÆ÷ÇåÁã
 224   1              CH=0;
 225   1              
 226   1              PCA_PWM0 = 0X00;
 227   1              CCAP0H=0;    // ³õÊ¼»¯Õ¼¿Õ±ÈÎª0% HµÄÖµ×°ÔØµ½LÖÐ
 228   1              CCAP0L=0;
 229   1              CCAPM0=0x42;    // ÉèÖÃÎªPWMÄ£Ê½, 8Î»£¬ÎÞÖÐ¶Ï¡£
 230   1      
 231   1              PCA_PWM1 = 0X00;
 232   1              CCAP1H=0;    // ³õÊ¼»¯Õ¼¿Õ±ÈÎª0%
 233   1              CCAP1L=0;
 234   1              CCAPM1=0x42;    // ÉèÖÃÎªPWMÄ£Ê½
 235   1              
 236   1              PCA_PWM2 = 0X00;
 237   1              CCAP2H=0;    // ³õÊ¼»¯Õ¼¿Õ±ÈÎª0%
 238   1              CCAP2L=0;
 239   1              CCAPM2=0x42;    // ÉèÖÃÎªPWMÄ£Ê½
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 5   

 240   1              
 241   1              PWM0_OUT_1();
 242   1              PWM1_OUT_1();
 243   1              PWM2_OUT_1();
 244   1      
 245   1              CR = 1;
 246   1      }
 247          
 248          void ADC_Init(void)
 249          {
 250   1              P1n_pure_input(0x38);
 251   1              P1ASF = 0X38; // ¿ªÍ¨P1.3 P1.4 P1.5µÄADÊäÈë¿Ú
 252   1      }
 253          
 254          void CMP_INT(void) interrupt 21
 255          {
 256   1              CMPCR1 &= ~0X40; // ÐèÈí¼þÇå³ýÖÐ¶Ï±êÖ¾Î»
 257   1              if(Step<5)      Step++;
 258   1              else            Step = 0;
 259   1              StepXL();
 260   1              TimeOut = 10;   //10ms³¬Ê±
 261   1      }
 262          
 263          void CMP_Init(void)
 264          {
 265   1              CMPCR1 = 0X8C;  // 1000 1100 ´ò¿ª±È½ÏÆ÷£¬P5.4×÷Îª±È½ÏÆ÷µÄ·´ÏàÊäÈë¶Ë£¬ADCÒý½Å×÷ÎªÕýÊäÈë¶Ë 
 266   1              CMPCR2 = 60;    // 60¸öÊ±ÖÓÂË²¨
 267   1              P5n_pure_input(0x10);
 268   1      }
 269          
 270          u8 StartMotor(void)
 271          {
 272   1              u16 timer,i;
 273   1              DISABLE_CMP_INT;        // ½ûÖ¹±È½ÏÆ÷ÖÐ¶Ï
 274   1              PWM_Value = 30;         // ³õÊ¼Õ¼¿Õ±È=16/256=6%
 275   1              Step = 0;
 276   1              StepXL();                       // ³õÊ¼Î»ÖÃ
 277   1              Delay_n_ms(5);//delay_ms(5);
 278   1              timer = 300;
 279   1      
 280   1              while(1)
 281   1              {
 282   2                      for(i=0; i<timer; i++)  delay_us(50);  // µÚÒ»´ÎÊÇ15ºÁÃë£¬¼ÓÉÏÉÏÃæµÄ5ºÁÃ×ÑÓÊ±£¬×Ü¼Æ´óÔ¼20ºÁÃë
 283   2                      timer -= timer /15 + 1;
 284   2                      if(timer < 25)  {
 285   3                              CMPCR1 &= ~0X40;        // ÐèÈí¼þÇå³ýÖÐ¶Ï±êÖ¾Î»
 286   3                              B_RUN = 1;                      // Âí´ïÔËÐÐ±êÖ¾Î»
 287   3                              PWM_Value = 0;          // Æô¶¯Íê³É¡£Í£×ª£¬µÈ´®¿ÚµÄPWW_SETÖµ
 288   3                              TimeOut = 10;           // 10ºÁÃ×³¬Ê±
 289   3                              ENABLE_CMP_INT;         // ´ò¿ª±È½ÏÆ÷ÖÐ¶Ï
 290   3                              return(1);
 291   3                      }
 292   2                      if( Step < 5)   Step++;
 293   2                      else                    Step = 0;
 294   2                      StepXL();
 295   2                      // SendString("Start Motor!\r\n");
 296   2              }
 297   1      }
 298          
 299          // void T0_Iint(void)
 300          // {
 301          //      Timer0_AsTimer();       /* Ê±Æ÷0ÓÃ×ö¶¨Ê±Æ÷      */
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 6   

 302          //      Timer0_12T();           /* Timer0 clodk = fo/12 12·ÖÆµ, default */
 303          //      Timer0_16bit();
 304          //      Timer0_Gate_INT0_P32(); /* Ê±Æ÷0ÓÉÍâ²¿INT0¸ßµçÆ½ÔÊÐí¶¨Ê±¼ÆÊý */
 305          //      TH0 = 0;
 306          //      TL0 = 0;
 307          //      TR0 = 1; // ´ò¿ª¶¨Ê±Æ÷0
 308          //      ET0 = 1;// ÔÊÐíET0ÖÐ¶Ï
 309          // }
 310          
 311          // void T0_Interrupt(void) interrupt 1
 312          // {
 313          //      Rx_cnt = 0;                     //Ò»µ©³öÏÖÒç³ö, Ôò¿ªÊ¼µÄn¸öÂö³åÎÞÐ§
 314          //      RxPulseWide = 1000;     //Í£Ö¹
 315          //      B_RxOk = 1;                     //ÐéÄâÊÕµ½Ò»¸öÂö³å
 316          // }
 317          
 318          /********************* INT0ÖÐ¶Ïº¯Êý *************************/
 319          // void INT0_int (void) interrupt INT0_VECTOR
 320          // {
 321          //      u16     j;
 322                  
 323          //      TR0 = 0;
 324          //      j = ((u16)TH0 << 8) + TL0;
 325          //      TH0 = 0;
 326          //      TL0 = 0;
 327          //      TR0 = 1;
 328          
 329          //      if(++Rx_cnt >= 5)       Rx_cnt = 5;
 330          //      j >>= 1;        //ÎªÁËºÃ´¦Àí, ×ª³Éµ¥Î»Îªus
 331          //      if((j >= 800) && (j <= 2000) && (Rx_cnt == 5))
 332          //      {
 333          //              RxPulseWide = j;
 334          //              B_RxOk = 1;             //±êÖ¾ÊÕµ½Ò»¸öÂö³å
 335          //      }
 336          
 337          // }
 338          
 339          /********************* ´®¿Ú³õÊ¼»¯º¯Êý *************************/
 340          bit busy;
 341          
 342          
 343          void UartInit(void)             //9600bps@24.000MHz
 344          {
 345   1              SCON = 0x50;            //8Î»Êý¾Ý,¿É±ä²¨ÌØÂÊ
 346   1              AUXR |= 0x01;           //´®¿Ú1Ñ¡Ôñ¶¨Ê±Æ÷2Îª²¨ÌØÂÊ·¢ÉúÆ÷
 347   1              AUXR |= 0x04;           //¶¨Ê±Æ÷2Ê±ÖÓÎªFosc,¼´1T
 348   1              T2L = 0x8F;             //Éè¶¨¶¨Ê±³õÖµ
 349   1              T2H = 0xFD;             //Éè¶¨¶¨Ê±³õÖµ
 350   1              AUXR |= 0x10;           //Æô¶¯¶¨Ê±Æ÷2
 351   1          ES = 1;                     //Ê¹ÄÜ´®¿Ú1ÖÐ¶Ï
 352   1      }
 353          
 354          
 355          /*----------------------------
 356          UART ÖÐ¶Ï·þÎñ³ÌÐò
 357          -----------------------------*/
 358          void Uart() interrupt 4 using 1
 359          {
 360   1          ES = 0;         //¹Ø±Õ´®¿ÚÖÐ¶Ï
 361   1              if (RI)
 362   1          {
 363   2                      PWW_Set = SBUF; // °ÑÊÕµ½µÄÊý¾Ý¸øÁËPWW_Set
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 7   

 364   2                      RI=0; // ´®¿Ú½ÓÊÕ±êÖ¾Çå0
 365   2                      B_RxOk = 1;
 366   2          }
 367   1          if (TI)
 368   1          {
 369   2              TI = 0;                 //Çå³ýTIÎ»
 370   2              busy = 0;               //ÇåÃ¦±êÖ¾
 371   2          }
 372   1              ES = 1;         //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
 373   1      }
 374          
 375          
 376          /*----------------------------
 377          ·¢ËÍ´®¿ÚÊý¾Ý
 378          ----------------------------*/
 379          void SendData(BYTE dat)
 380          {
 381   1          while (busy);               //µÈ´ýÇ°ÃæµÄÊý¾Ý·¢ËÍÍê³É
 382   1          ACC = dat;                  //»ñÈ¡Ð£ÑéÎ»P (PSW.0)
 383   1          if (P)                      //¸ù¾ÝPÀ´ÉèÖÃÐ£ÑéÎ»
 384   1          {
 385   2                      #if (PARITYBIT == ODD_PARITY)
                                              TB8 = 0;                //ÉèÖÃÐ£ÑéÎ»Îª0
                              #elif (PARITYBIT == EVEN_PARITY)
                                              TB8 = 1;                //ÉèÖÃÐ£ÑéÎ»Îª1
                              #endif
 390   2          }
 391   1          else
 392   1          {
 393   2                      #if (PARITYBIT == ODD_PARITY)
                                              TB8 = 1;                //ÉèÖÃÐ£ÑéÎ»Îª1
                              #elif (PARITYBIT == EVEN_PARITY)
                                              TB8 = 0;                //ÉèÖÃÐ£ÑéÎ»Îª0
                              #endif
 398   2          }
 399   1          busy = 1;
 400   1          SBUF = ACC;                 //Ð´Êý¾Ýµ½UARTÊý¾Ý¼Ä´æÆ÷
 401   1      }
 402          
 403          /*----------------------------
 404          ·¢ËÍ×Ö·û´®
 405          ----------------------------*/
 406          void SendString(char *s)
 407          {
 408   1          while (*s)                  //¼ì²â×Ö·û´®½áÊø±êÖ¾
 409   1          {
 410   2              SendData(*s++);         //·¢ËÍµ±Ç°×Ö·û
 411   2          }
 412   1      }
 413          
 414          
 415          /**********************************************/
 416          
 417          void main(void)
 418          {
 419   1              PWM_Init();
 420   1              ADC_Init();
 421   1              CMP_Init();
 422   1              UartInit();
 423   1              // T0_Iint();
 424   1      
 425   1              IE0 = 0;        // Çå³ýÍâÖÐ¶Ï0±êÖ¾Î»
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 8   

 426   1              // EX0 = 1;     // INT0 Enable
 427   1              // IT0 = 1;     //INT0 ÏÂ½µÑØÖÐ¶Ï
 428   1              
 429   1              // RxPulseWide = 1000;
 430   1              PWW_Set = 0;
 431   1              cnt10ms = 0;
 432   1              Rx_cnt  = 0;
 433   1              TimeOut = 0;
 434   1      
 435   1              EA = 1; // ´ò¿ª×ÜÖÐ¶Ï
 436   1              // Delay_n_ms(1);       //ÑÓÊ±
 437   1              SendString("BLDC Test !\r\n");
 438   1              while (1)
 439   1              {
 440   2                      Delay_n_ms(1);  //ÑÓÊ±1ms, Ö÷³ÌÐòÔÚ´Ë½ÚÅÄÏÂÔËÐÐ
 441   2      
 442   2                      if (TimeOut > 0)
 443   2                      {
 444   3                              if(--TimeOut == 0)      //¶Â×ª³¬Ê±
 445   3                              {
 446   4                                      DISABLE_CMP_INT;        // ¹Ø±È½ÏÆ÷ÖÐ¶Ï
 447   4                                      CCAP0H=0;       CCAP1H=0;       CCAP2H=0;  // Õ¼¿Õ±ÈÎª0
 448   4                                      PWM0_L=0;       PWM1_L=0;       PWM2_L=0;
 449   4                                      // RxPulseWide = 1000;
 450   4                                      PWW_Set   = 0;
 451   4                                      PWM_Value = 0;
 452   4                                      B_RxOk = 0;
 453   4                                      B_RUN  = 0;
 454   4                                      Rx_cnt = 0;
 455   4                                      TimeOut = 0;
 456   4                                      SendString("Time Out!\r\n");
 457   4      
 458   4                                      Delay_n_ms(250);        //¶Â×ªÊ±,ÑÓÊ±1ÃëÔÙÆô¶¯
 459   4                                      Delay_n_ms(250);
 460   4                                      Delay_n_ms(250);
 461   4                                      Delay_n_ms(250);
 462   4      
 463   4                              }
 464   3                      }
 465   2                      
 466   2                      // if(B_RxOk)   //ÊÕµ½Ò»¸öÂö³å
 467   2                      // {
 468   2                      //      B_RxOk = 0;
 469   2                      //      j = RxPulseWide;
 470   2                      //      if(j >= 1100)                           // 1100~1610¶ÔÓ¦PWMÕ¼¿Õ±ÈÖµ0~255
 471   2                      //      {
 472   2                      //              j = (j - 1100) >> 1;    //2us¶ÔÓ¦PWMÒ»¸ö²½½ø
 473   2                      //              if(j > 256)     j = 255;
 474   2                      //      }
 475   2                      //      else    j = 0;
 476   2                      //      PWW_Set = (u8)j;
 477   2                      // }
 478   2                      // SendData(PWW_Set);
 479   2                      if(B_RxOk) // Èç¹û´®¿ÚÊÕµ½Êý¾Ý
 480   2                      {
 481   3                              // SendData(PWW_Set);
 482   3                              B_RxOk = 0;
 483   3                              // if(rec==0x22)// ¼ÓËÙÃüÁî
 484   3                              // {
 485   3                              //      if(PWM_Value<250)
 486   3                              //      {
 487   3                              //              PWM_Value++; // Ôö¼ÓÕ¼¿Õ±È
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 9   

 488   3                              //      }
 489   3                              // }
 490   3                              // else if(rec==0x33)// ¼õËÙÃüÁî
 491   3                              // {
 492   3                              //      if(PWM_Value>30)
 493   3                              //      {
 494   3                              //              PWM_Value--; // ¼õÐ¡Õ¼¿Õ±È
 495   3                              //      }
 496   3                              // }
 497   3                              // else if(rec==0x11) // Æô¶¯ÃüÁî
 498   3                              // {
 499   3                              //      StartMotor();   // Æô¶¯Âí´ï
 500   3                              //      CMPCR1 &= ~0X40; // ÐèÈí¼þÇå³ýÖÐ¶Ï±êÖ¾Î»
 501   3                              //      ENABLE_CMP_INT; // ´ò¿ª±È½ÏÆ÷ÖÐ¶Ï
 502   3                              //      B_RUN = 1;
 503   3                              //      TimeOut = 0;
 504   3                              // }
 505   3                              // else if(rec==0x44) // Í£Ö¹ÃüÁî
 506   3                              // {
 507   3                              //      CCAP0H=0;CCAP1H=0;CCAP2H=0;  // Õ¼¿Õ±È¶¼ÖÃ0
 508   3                              //      EA = 0; // ¹Ø±ÕÈ«¾ÖÖÐ¶Ï
 509   3                              //      DISABLE_CMP_INT; // ¹Ø±Õ±È½ÏÆ÷ÖÐ¶Ï
 510   3                              // }
 511   3                      }
 512   2                      if(!B_RUN && (PWW_Set >= 30))           // PWM_Set >= 30, ²¢ÇÒÂí´ïÎ´ÔËÐÐ, ÔòÆô¶¯Âí´ï
 513   2                      {
 514   3                              StartMotor();   // Æô¶¯Âí´ï
 515   3                              // TimeOut = 0;
 516   3                      }
 517   2                      
 518   2                      
 519   2                      if(++cnt10ms >= 10)             // 10msÊ±Ï¶
 520   2                      {
 521   3                              // SendData(cnt10ms);
 522   3                              cnt10ms = 0;
 523   3                              if(B_RUN)
 524   3                              {
 525   4                                      if(PWM_Value < PWW_Set) PWM_Value++;
 526   4                                      if(PWM_Value > PWW_Set) PWM_Value--;
 527   4                                      if(PWM_Value < 20)      // Í£×ª
 528   4                                      {
 529   5                                              PWM_Value = 0;
 530   5                                              B_RUN = 0;
 531   5                                              CCAP0H=0;       CCAP1H=0;       CCAP2H=0;  // Õ¼¿Õ±ÈÎª0
 532   5                                              PWM0_L=0;       PWM1_L=0;       PWM2_L=0;
 533   5                                              DISABLE_CMP_INT; // ¹Ø±È½ÏÆ÷ÖÐ¶Ï
 534   5                                              SendString("Stop Motor!\r\n");
 535   5                                      }
 536   4                              }
 537   3                      }
 538   2              }
 539   1      }
 540          
 541          
 542          
 543          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    791    ----
   CONSTANT SIZE    =     40    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.01   MAIN_V20                                                              07/06/2018 14:39:11 PAGE 10  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
